<!-- Table of Content -->
[toc]

---

> <font size="18px">**NOTE:**</font>
> Notes written by: <font size="5px">**Offensive Hacker**</font>
> These notes is based on OffSec's Certification named PWK [Penetration Testing With Kali Linux]. The content of these notes are hand written. Remember, I am not a professional, so if you find any type of mistake then correct that on your own!



# Chapter 3: Command Line Fun
---

*In this module, we'll taken an introductory look at a few popular Linux command line programs.*


## The Bash Environment
---
[Bash]( https://en.wikipedia.org/wiki/Bash_(Unix_shell) ) is an sh-compatible shell that allows us to run complex commands and programs and perform different tasks from a terminal window. It incorporates useful features from both the [KornShell]( https://en.wikipedia.org/wiki/KornShel) (ksh) and [C shell]( https://en.wikipedia.org/wiki/C_shel) (csh).


### Environment Variables
---
When opening a terminal window, a new Bash process, which hash its own **environment variables**, is initialized. These variables are a form of global storgae for various settings inherited by any applications that are run during that terminal session. One of the most commonly-referenced environment variable is `PATH`, which is a color-separated list of directory paths that Bash will search through whenever a command is run without a full path.

We can view  the contents of a given environment variable with the echo command followed by the “$” character and an environment variable name. For example, let’s take a look at the contents of 
the PATH environment variable:
```bash
kali@kali:~$ echo $PATH 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Some other useful environment variables include USER, PWD, and HOME, which hold the values of the current terminal user’s username, present working directory, and home directory respectively:
```bash
kali@kali:~$ echo $USER 
kali 
 
kali@kali:~$ echo $PWD 
/home/kali 
 
kali@kali:~$ echo $HOME 
/home/kali
```

An environment variable can be defined with the **export** command. For example, if we are scanning a target and don't want to type in the system's IP address repeatedly, we can quickly assign it an environment variable and use that instead:
```bash
kali@kali:~$ export b=10.11.1.220 
 
kali@kali:~$ ping -c 2 $b 
PING 10.11.1.220 (10.11.1.220) 56(84) bytes of data. 
64 bytes from 10.11.1.220: icmp_seq=1 ttl=62 time=2.23 ms 
64 bytes from 10.11.1.220: icmp_seq=2 ttl=62 time=1.56 ms 
 
--- 10.11.1.220 ping statistics --- 
2 packets transmitted, 2 received, 0% packet loss, time 1002ms 
rtt min/avg/max/mdev = 1.563/1.900/2.238/0.340 ms
```

The `export` command makes the variable accessible to any subprocesses we might spawn from our current Bash instance. If we set an environment variable without `export` it will only be available in the current shell.

We will use the `$$` variable to display the process ID of the current shell instance to make sure that we are indeed issuing commands in two different shells:
```bash
kali@kali:~$ echo "$$" 
1827 
 
kali@kali:~$ var="My Var" 
 
kali@kali:~$ echo $var 
My Var 
 
kali@kali:~$ bash 
kali@kali:~$ echo "$$" 
1908 
 
kali@kali:~$ echo $var 
 
kali@kali:~$ exit 
exit 
 
kali@kali:~$ echo $var 
My Var 
 
kali@kali:~$ export othervar="Global Var" 
 
kali@kali:~$ echo $othervar 
Global Var 
 
kali@kali:~$ bash 
 
kali@kali:~$ echo $othervar 
Global Var 
 
kali@kali:~$ exit 
exit 
kali@kali:~$
```

- `env`: To check other environment variable


### Bash History Tricks
---
- `history`: to see the records of the commands that have been entered into the shell.
```bash
kali@kali:~$ history 
  1  cat /etc/lsb-release 
  2  clear 
  3  history
  ...
  772   find / -name passwd 2>/dev/null
```

  - Run the long command again
```bash
kali@kali:~$ history $772 #write the number of the command to run the command
find / -name passwd 2>/dev/null
/etc/passwd
...
```

  - Run the privious command:
```bash
kali@kali:~$ sudo systemctl restart apache2

kali@kali:~$ history !!  # you can run the privious command by typing !!
sudo systemctl restart apache2

kali@kali:~$ 
```

- You can also use the up and down arrow key to access the history in your terminal
- You can also hold `Ctrl + R` key to access the *reverse-i-search*, then type any character (e.g., i), it will suggest you to command from the history. Press the `enter` to run the command Or press the `Ctrl + C` to terminate the *reverse-i-search*.


### Piping and Redirection
---
Every program run from the command line has three data streams connected to it that serve as communication channels with the external environment. These streams are defined as follows:

!["Streams_connected_to_command_line_programs"](image-1.png)

Piping (using the `|` operator) and redirection (using the `>` and `<` operators) connects these streams between programs and files to accommodate a near infinite number of possible use cases.

#### Redirection
---

- Redirecting to a *New File*

```bash
kali@kali:~$ ls 
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos 
 
kali@kali:~$ echo "test" 
test 
 
kali@kali:~$ echo "test" > redirection_test.txt 
 
kali@kali:~$ ls  
Desktop  Documents  Downloads  Music  Pictures  Public  redirection_test.txt  Template 
 
kali@kali:~$ cat redirection_test.txt 
test 
 
kali@kali:~$ echo "Kali Linux is an open source project" > redirection_test.txt 
 
kali@kali:~$ cat redirection_test.txt 
Kali Linux is an open source project
```

- Redirecting to an *Existing File*
```bash
kali@kali:~$ echo "that is maintained and funded by Offensive Security" >> redirection
_test.txt  
 
kali@kali:~$ cat redirection_test.txt  
Kali Linux is an open source project 
that is maintained and funded by Offensive Security
```

- Redirecting from a *File*
```bash
kali@kali:~$ wc -m < redirection_test.txt  
89 
```

- Redirecting *STDERR*
```bash
kali@kali:~$ ls . 
Desktop  Documents  Downloads  Music  Pictures  Public  redirection_test.txt  Template 
 
kali@kali:~$ ls ./test 
ls: cannot access '/test': No such file or directory 
 
kali@kali:~$ ls ./test 2>error.txt 
 
kali@kali:~$ cat error.txt  
ls: cannot access '/test': No such file or directory 
```

#### Piping
---

```bash
kali@kali:~$ cat error.txt  
ls: cannot access '/test': No such file or directory 
 
kali@kali:~$ cat error.txt | wc -m 
53 
 
kali@kali:~$ cat error.txt | wc -m > count.txt 
 
kali@kali:~$ cat count.txt  
53
```

### Text Searching and Manipulation
----
In this section, we will gain efficiency with file and text handling by introducing a few commands: grep, sed, cut, and awk. Advanced usage of some of these tools requires a good understanding of how regular expressions (regex) work. A regular expression is a special text string for describing a search  pattern.

#### Grep
---
- `grep`: searches for text files for the occurrence of a given regular expression and outputs any line containing a match to the standard output, which is usually the terminal screen.
  - `-r` and `-i` are the most commonly used switches. `-r` use for recursive searching and `-i` to ignore the text case.


#### Sed
---
- `sed`: sed is a powerful stream editor.
- But very complex
- Here is an example of showing sed usage:
```bash
kali@kali:~$ echo "I need to try hard" | sed 's/hard/harder/' 
I need to try harder #hard replaced by harder
```

#### Cut
---
- `cut`: It is used to extract section of text from a line and output it to the standard output. Some f the most commonly-user switches include `-f` for the field number we are cutting and `-d` for the field delimiter:
```bash
kali@kali:~$ echo "I hack binaries,web apps,mobile apps, and just about anything else"
| cut -f 2 -d "," 
web apps
```

#### AWK
---
- `awk`: is a programming language designed for text processing and is typically used as a data extraction and reporting tool. It is also extremely powerful and can be quite complex.

```bash
kali@kali:~$ echo "hello::there::friend" | awk -F "::" '{print $1, $3}' 
hello friend 
```

#### Practice Examples
----
Download the text file from here: https://www.offensive-security.com/pwk-files/access_log.txt.gz

TASK: Find the attacker's ip, who done brute force attack.

```bash
kali@kali:~$ gunzip access_log.txt.gz

kali@kali:~$ mv access_log.txt access.log

kali@kali:~$ wc -l access.log 
1173 access.log

kali@kali:~$ head access.log 
201.21.152.44 - - [25/Apr/2013:14:05:35 -0700] "GET /favicon.ico HTTP/1.1" 404 89 "-" 
"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.
0.1410.64 Safari/537.31" "random-site.com" 
70.194.129.34 - - [25/Apr/2013:14:10:48 -0700] "GET /include/jquery.jshowoff.min.js HT
TP/1.1" 200 2553 "http://www.random-site.com/" "Mozilla/5.0 (Linux; U; Android 4.1.2; 
en-us; SCH-I535 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobil
e Safari/534.30" "www.random-site.com" 
...

kali@kali:~$ cat access.log | cut -d " " -f 1 | sort -u 
201.21.152.44 
208.115.113.91 
208.54.80.244 
208.68.234.99 
70.194.129.34 
72.133.47.242 
88.112.192.2 
98.238.13.253 
99.127.177.95

kali@kali:~$ cat access.log | cut -d " " -f 1 | sort | uniq -c | sort -urn 
   1038 208.68.234.99 
     59 208.115.113.91 
     22 208.54.80.244 
     21 99.127.177.95 
      8 70.194.129.34 
      1 201.21.152.44

kali@kali:~$ cat access.log | grep '208.68.234.99' | cut -d "\"" -f 2 | uniq -c 
   1038 GET //admin HTTP/1.1

kali@kali:~$ cat access.log | grep '208.68.234.99' | grep '/admin ' | sort -u 
208.68.234.99 - - [22/Apr/2013:07:51:20 -0500] "GET //admin HTTP/1.1" 401 742 "-" "Teh 
Forest Lobster" 
208.68.234.99 - admin [22/Apr/2013:07:51:25 -0500] "GET //admin HTTP/1.1" 200 575 "-""Teh Forest Lobster" 
... 
 
kali@kali:~$ cat access.log|grep '208.68.234.99'| grep -v '/admin ' 
kali@kali:~$ 

```

Apparently  `208.68.234.99`  has  been  involved  in  an  HTTP  brute  force  attempt  against  this  web 
server. Furthermore, after about 1000 attempts, it seems like the brute force attempt succeeded, 
as indicated by the “HTTP 200” message. 

**Question** Using `/etc/passwd`, extract the user and home directoru fields for all users on your Kali machine for which the shell is set to `/bin/false`. Make sure you use a Bash one-liner to print the output to the screen. The output should lool similar like below:

```bash
kali@kali:~$ YOUR COMMAND HERE... 
The user mysql home directory is /nonexistent 
The user Debian-snmp home directory is /var/lib/snmp 
The user speech-dispatcher home directory is /var/run/speech-dispatcher 
The user Debian-gdm home directory is /var/lib/gdm3
```
**Solution:**

```
kali@kali:~$ cat /etc/passwd | awk -F ":" '{print "The user " $1 " home directory is "  $7 }'
The user root home directory is /bin/bash
The user daemon home directory is /usr/sbin/nologin
The user bin home directory is /usr/sbin/nologin
The user sys home directory is /usr/sbin/nologin
The user sync home directory is /bin/sync
The user games home directory is /usr/sbin/nologin
...
```

### Editing Files from the Command Line
---

> Please checkout the given text-editor on your own!

Here are some of the popular text editor which you can use as your preference:

- Nano
- vim
- micro
- vi

### Compairing Files
---

#### Comm
---

File comparison may seem irrelevant, but system administrators, network engineers, penetration testers, IT support technicians and many other technically-oriented professionals rely on this skill pretty often.

- `comm`: for compare files
```bash
kali@kali:~$ cat scan-b.txt 
192.168.1.1 
192.168.1.3 
192.168.1.4 
192.168.1.5 
192.168.1.6

kali@kali:~$ comm scan-a.txt scan-b.txt  
                                192.168.1.1 
192.168.1.2 
                                192.168.1.3 
                                192.168.1.4 
                                192.168.1.5 
              192.168.1.6 
               
kali@kali:~$ comm -12 scan-a.txt scan-b.txt 
192.168.1.1 
192.168.1.3 
192.168.1.4 
192.168.1.5
```

- `comm -12 file1 file2`:  Print only lines present in both file1 and file2.


#### Diff
----
- `diff`: detect differences between files, similar to `comm` command.
- But it is much more complex and supports many formats.
- Two of the most popular formats include the *context format* (`-c`) and the *unified format* (`-u`).

```bash
kali@kali:~$ diff -c scan-a.txt scan-b.txt 
*** scan-a.txt  2018-02-07 14:46:21.557861848 -0700 
--- scan-b.txt  2018-02-07 14:46:44.275002421 -0700 
*************** 
*** 1,5 **** 
  192.168.1.1 
- 192.168.1.2 
  192.168.1.3 
  192.168.1.4 
  192.168.1.5 
--- 1,5 ---- 
  192.168.1.1 
  192.168.1.3 
  192.168.1.4 
  192.168.1.5 
+ 192.168.1.6 
 
kali@kali:~$ diff -u scan-a.txt scan-b.txt 
--- scan-a.txt  2018-02-07 14:46:21.557861848 -0700 
+++ scan-b.txt  2018-02-07 14:46:44.275002421 -0700 
@@ -1,5 +1,5 @@ 
 192.168.1.1 
-192.168.1.2 
 192.168.1.3 
 192.168.1.4 
 192.168.1.5 
+192.168.1.6 
```

- `vimdiff`: You can also use `vimdiff` to compare the two different files.
```bash
kali@kali:~$ vimdiff scan-a.txt scan-b.txt
```

![vimdiff_command_output](image-2.png)

Notice thath the differences are easily spotted because of the colored highlights.


### Managing Processes
---
- `fg`: activate background processes in foreground 
- `bg`: send foreground processes to background. We can send a running process in background by pressing `Ctrl + Z` on terminal.
- we can also use `&` to send a process in background:
```bash
kali@kali:~$ ping -c 400 localhost > ping.txt &
kali@kali:~$
kali@kali:~$ fg
ping -c 400 localhost > ping.txt &
...
^Z
[1]+  Stopped                 ping -c 400 localhost > ping.txt
kali@kali:~$ bg
[1]+ ping -c 400 localhost > ping.txt 
kali@kali:~$ 
```

### Jobs control: jobs and fg
---
To quickly check the status of our ICMP echo requests, we need to make use of two additional commands: `jobs` and `fg`.
The built-in **`jobs`** utility lists the jobs that are running in the current terminal session, while **`fg`** returns a job to the foreground. These commands are shown in action below:
```bash
kali@kali:~$ ping -c 400 localhost > ping_results.txt 
^Z 
[1]+  Stopped                 ping -c 400 localhost > ping_results.txt 
 
kali@kali:~$ find / -name sbd.exe 
^Z 
[2]+  Stopped                 find / -name sbd.exe 
 
kali@kali:~$ jobs 
[1]-  Stopped                 ping -c 400 localhost > ping_results.txt 
[2]+  Stopped                 find / -name sbd.exe 
 
kali@kali:~$ fg %1 
ping -c 400 localhost > ping_results.txt 
^C 
 
kali@kali:~$ jobs 
[2]+  Stopped                 find / -name sbd.exe 
 
kali@kali:~$ fg 
find / -name sbd.exe 
/usr/share/windows-resources/sbd/sbd.exe 
```

There are a few things worth mentioning:

First, the odd **^C** character represents the keystroke combination `Ctrl + C`. We can use this shortcut  to terminate a long-rinning process and regain control of the terminal.

Second, the use of "%1" in the **`fg %1`** command is new. There are various ways to refer to a job in the shell. The "%" character followed by a JobID represents a job specification. The JobID can be a process ID (PID) number or you can use one of the following symbol combination:

- `%Number`: Refers to a job number such as `%1` or `%2`
- `%String`: Refers to the beginning of the suspended command's name such as `%commandNameHere` or `%ping`
- `%+` OR `%%`: Refers to the current job
- `%-`: Refers to the previous job

Note that if only one process has been backgrounded, the job number is not needed.


### Process Control: ps and kill
----

- `ps`: To check the *process status*
- `kill`: To kill the process

**Demonstration of `ps` command:**

```bash
kali@kali:~$ ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD 
root          1      0  0 10:18 ?        00:00:02 /sbin/init 
root          2      0  0 10:18 ?        00:00:00 [kthreadd] 
root          3      2  0 10:18 ?        00:00:00 [rcu_gp] 
root          4      2  0 10:18 ?        00:00:00 [rcu_par_gp] 
root          5      2  0 10:18 ?        00:00:00 [kworker/0:0-events] 
root          6      2  0 10:18 ?        00:00:00 [kworker/0:0H-kblockd] 
root          7      2  0 10:18 ?        00:00:00 [kworker/u256:0-events_unbound 
root          8      2  0 10:18 ?        00:00:00 [mm_percpu_wq] 
root          9      2  0 10:18 ?        00:00:00 [ksoftirqd/0] 
root         10      2  0 10:18 ?        00:00:00 [rcu_sched]
...

# -e: select all processes
# -f: display full format listing (UID, PID, PPID, etc.)
```

- finding a process:
```bash
kali@kali:~$ ps -fC leafpad 
UID         PID   PPID  C STIME TTY          TIME CMD 
kali       1307    938  0 10:57 ?        00:00:00 leafpad 


# -C: select by command name
# -f: display full format listing
```

`ps` is really the Swiss Army knife of process management.


**Demonstration of `kill` command:**

```bash
kali@kali:~$ leafpad &
[+] 1307
kali@kali:~$ kill 1307 
 
kali@kali:~$ ps aux | grep leafpad 
kali       1313  0.0  0.0   6144   888 pts/0    S+   10:59   0:00 grep leafpad
```

Becasue the default signal for `kill` is *SIGTERM* (request termination), our application has been terminated. This has been verified in above instance by using `ps` after killing Leafpad.


### File and Command Monitoring
---
It is extremely valuable to know how to monitor files and commands in real-time during the course of a penetration test. Two commands that help with such tasks are `tail` and `watch`.

#### tail
----

`tail`: The most common use of `tail` command is to monitor log file entries as they are being written.

For example, we may want to monitor the Apache logs to see if a web server is being contacted by a given client we are attempting to attack via client-side exploit. This example will do just that:

```bash
kali@kali:~$ sudo tail -f /var/log/apache2/access.log  
127.0.0.1 - - [02/Feb/2018:12:18:14 -0500] "GET / HTTP/1.1" 200 3380 "-" "Mozilla/5.0 
(X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0" 
127.0.0.1 - - [02/Feb/2018:12:18:14 -0500] "GET /icons/openlogo-75.png HTTP/1.1" 200 6
040 "http://127.0.0.1/" "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firef
ox/52.0" 
127.0.0.1 - - [02/Feb/2018:12:18:15 -0500] "GET /favicon.ico HTTP/1.1" 404 500 "-" "Mo
zilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"
....



# -f: option (follow) is veey useful as it continuously updates the output as the target file grows.
```

Another convenient switch is `-nX`, which outputs the last `X` number of lines, instead of the default value of 10.


#### watch
---

The watch command is used to run a designated command at regular intervals. By default, it runs every two seconds but we can specify a different interval by using the `-n X` option to have it run every "X" number of seconds. For eaxmple, this command will list logged-in uses (via the `-w` command) once every 5 seconds:

```bash
kali@kali:~$ watch -n 5 w 
 
............ 
 
Every 5.0s: w                                     kali: Tue Jan 23 21:06:03 2018 
 
 21:06:03 up 7 days,  3:54,  1 user,  load average: 0.18, 0.09, 0.03 
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT 
kali     tty2     :0               16Jan18  7days 16:29   2.51s /usr/bin/python
```
To terminate the watch command and return to the interactive terminal, use `Ctrl + C`.


### Downloading Files
---

#### wget
---
- `wget`: extensively used command, downloads files using the HTTP/HTTPS and FTP protocols.

**Demonstration of `wget` command:**
```bash
kali@kali:~$ wget -O report_wget.pdf https://www.offensive-security.com/reports/penetration-testing-report-2013.pdf
ation-testing-sample-report-2013.pdf 
--2018-01-28 20:30:04--  https://www.offensive-security.com/reports/penetration-testin-sample-report-2013.pdf
Resolving www.offensive-security.com (www.offensive-security.com)... 192.124.249.5 
Connecting to www.offensive-security.com (www.offensive-security.com)|192.124.249.5|:4 
HTTP request sent, awaiting response... 200 OK 
Length: 27691955 (26M) [application/pdf] 
Saving to: ‘report_wget.pdf’
report_wget.pdf     100%[===================>]  26.41M   766KB/s    in 28s      
 
2018-01-28 20:30:33 (964 KB/s) - ‘report_wget.pdf’ saved [27691955/27691955]



# -O: switch to save the destination file witha different name on the local machine
```


#### curl
----
**`curl`** is a tool to transfer data to or from a server using a host of protocols including IMAP/S, POP3/S, SCP, SFTP, SMB/S, SMTP/S, TELNET, TFTP, and others. A penetration tester can use this to download or upload files and build complex requests. It most basic use is very similar to wget, as show below:

```bash
kali@kali:~$ curl -o report.pdf https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
-testing-sample-report-2013.pdf 
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current 
                                 Dload  Upload   Total   Spent    Left  Speed 
100 26.4M  100 26.4M    0     0  1590k      0  0:00:17  0:00:17 --:--:--  870k
```

#### axel
---
**`axel`** is a download accelerator that transfers a file from a FTP or HTTP server through multiple connections. The most common is `-n`, which is used to specify the number of multiple connections to use. In the following example, we are also using the `-a` option for a more concise progress indicator and `-o` to specify a different file name for the downloaded file.

```bash
kali@kali:~$ axel -a -n 20 -o report_axel.pdf https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf 
Initializing download: https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
File size: 27691955 bytes 
Opening output file report_axel.pdf 
Starting download 
 
Connection 0 finished 
Connection 1 finished 
Connection 2 finished 
Connection 3 finished 
Connection 4 finished 
Connection 5 finished 
Connection 6 finished 
Connection 7 finished 
Connection 8 finished 
Connection 9 finished 
Connection 10 finished 
Connection 11 finished 
Connection 13 finished 
Connection 14 finished 
Connection 15 finished 
Connection 16 finished
Connection 18 finished 
[100%] [..............................................................................
.....................................................................................] 
[  11.1MB/s] [00:00] 
 
Downloaded 26.4 Megabyte in 2 seconds. (11380.17 KB/s)

```


### Customizeing the Bash Environment
----
Earlier in this chapter, we discussed environment variables and the history command. We can use a number of environment variables to change how the history command operates and returns data, the most common including *HISTCONTROL*, *HISTIGNORE*, and *HISTTIMEFORMAT*.

#### HISTCONTROL
----

The *HISTCONTROL* variable defines whether or not to remove duplicate commands, commands that begin with spaces from the history, or both. By default, both are removed but you may find it more useful to only omit duplicates.

```bash
kali@kali:~$ export HISTCONTROL=ignoredups
```

#### HISTIGNORE
----

The *HISTIGNORE* variable is particularly useful for filtering out basic commands that run frequently, such as `ls`, `exit`, `bg`, etc:

```bash
kali@kali:~$ export HISTIGNORE="&:ls:[bf]g:exit:history" 
 
kali@kali:~$ mkdir test 
 
kali@kali:~$ cd test 
 
kali@kali:~/test$ ls 
 
kali@kali:~/test$ pwd 
/home/kali/test 
 
kali@kali:~/test$ ls 
 
kali@kali:~/test$ history 
    1  export HISTIGNORE="&:ls:[bf]g:exit:history" 
    2  mkdir test 
    3  cd test 
    4  pwd
```

#### HISTTIMEFORMAT
----

Lastly, *HISTTIMEFORMAT* controls date and/or time stamps in the output of the `history` command:

```bash
kali@kali:~/test$ export HISTTIMEFORMAT='%F %T ' 
 
kali@kali:~/test$ history 
    1  2018-02-12 13:37:33 export HISTIGNORE="&:ls:[bf]g:exit:history" 
    2  2018-02-12 13:37:38 mkdir test 
    3  2018-02-12 13:37:40 cd test 
    4  2018-02-12 13:37:43 pwd 
    5  2018-02-12 13:37:51 export HISTTIMEFORMAT='%F %T '
```

#### Alias
---

`alias`: is a string, replace the command name, you can specify your custom name to replace the orignal command name

```bash
kali@kali:~$ alias lsa='ls -la' 
 
kali@kali:~$ lsa 
total 8308 
 
........ 
-rw-------  1 kali kali     5542 Jan 22 09:56 .bash_history 
-rw-r--r--  1 kali kali     3391 Apr 25  2017 .bashrc 
drwx------  9 kali kali     4096 Oct  2 21:29 .cache 
```

```bash
kali@kali:~$ alias mkdir='ping -c 1 localhost' 
 
kali@kali:~$ mkdir 
PING localhost(localhost (::1)) 56 data bytes 
64 bytes from localhost (::1): icmp_seq=1 ttl=64 time=0.121 ms 
 
--- localhost ping statistics --- 
1 packets transmitted, 1 received, 0% packet loss, time 0ms 
rtt min/avg/max/mdev = 0.121/0.121/0.121/0.000 ms 
```
Should a situation like this occur, the solution is simple. We can either exit the current shell sessoin or use the unalias command to unset the offending alias:

```bash
kali@kali:~$ unalias mkdir 
 
kali@kali:~$ mkdir 
mkdir: missing operand 
Try 'mkdir --help' for more information.
```


### Persistent Bash Customization
----
The behavior of interactive shells in Bash is determined by the system-wide bashrc file located in `/etc/bash.bashrc`. The system-wide Bash settings can be overridden by editing the `.bashrc` file located in any user’s home directory.

In the previous section, we explored the alias command, which sets an alias for the current terminal session. We can also insert this command into the `.bashrc` file in a user’s home directory to set a persistent alias. The `.bashrc` script is executed any time that user logs in. Since this file is a shell script, we can insert any command that could be executed from the command prompt. 

Let’s examine a few lines of the default `/home/kali/.bashrc` file in Kali Linux:

```bash
kali@kali:~$ cat ~/.bashrc 
# ~/.bashrc: executed by bash(1) for non-login shells. 
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc) 
# for examples 
... 
# for setting history length see HISTSIZE and HISTFILESIZE in bash(1) 
HISTSIZE=1000 
HISTFILESIZE=2000 
 
# enable color support of ls and also add handy aliases 
if [ -x /usr/bin/dircolors ]; then 
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors - 
    alias ls='ls --color=auto' 
...
```

You  might  recognize  the  *HISTSIZE*  and  *HISTFILESIZE*  environment  variables  and  the  `alias` command that displays colored output.